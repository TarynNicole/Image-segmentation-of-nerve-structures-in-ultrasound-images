# -*- coding: utf-8 -*-
"""Untitled19.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kQ88zraujgpsBpJJ-t1fZXQrJkZkTcfb
"""


your_username = 'Taryn'
your_password = 'abc123'

import streamlit as st
import cv2
from PIL import Image
from io import BytesIO
import base64
import tensorflow
from tensorflow.keras.models import load_model
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1.axes_divider import make_axes_locatable
uploaded_images={}
# Function to convert image to bytes for download
def convert_image(img):
    buf = BytesIO()
    img.savefig(buf, format="PNG")
    byte_im = buf.getvalue()
    return byte_im

def dice_coef(y_true, y_pred, smooth = 1.):
    y_true_f = K.flatten(y_true)
    y_pred_f = K.flatten(y_pred)
    intersection = K.sum(y_true_f * y_pred_f)
    return (2. * intersection + smooth) / (K.sum(y_true_f) + K.sum(y_pred_f) + smooth)


def dice_coef_loss(y_true, y_pred):
    return -dice_coef(y_true, y_pred)

def iou(y_true, y_pred, smooth = 1.):
    intersection = K.sum(y_true * y_pred)
    sum_ = K.sum(y_true) + K.sum(y_pred)
    jac = (intersection + smooth) / (sum_ - intersection + smooth)
    return jac
MAX_FILE_SIZE=5*1024*1024
# Function for MC Dropout Inference
def mc_dropout_inference(model, image, num_samples):
    all_predictions = []

    for _ in range(num_samples):
        # Perform a forward pass with dropout
        prediction = model.predict(image, verbose=0)
        all_predictions.append(prediction)

    return np.array(all_predictions)

# Function for image segmentation
def segment_image(upload, col1, col2, col3):
    # Load model
    unet_drop1 = load_model('2_unet_bayes_drop_ner_seg.hdf5', custom_objects={'dice_coef_loss': dice_coef_loss, 'iou': iou, 'dice_coef': dice_coef})
    unet_drop1.load_weights('2_unet_bayes_drop_ner_seg.hdf5')
    image = Image.open(upload)
    image = np.asarray(image)
    img = cv2.resize(image, (128, 128))
    img = img[np.newaxis, :, :, :]
    img = img / 255
    mc_predictions = mc_dropout_inference(unet_drop1, img, 20)
    pred = unet_drop1.predict(img)
    uncertainty = np.var(mc_predictions, axis=0)

    # Plot Original Image
    col1.write("Original Image")
    col1.image(np.squeeze(img), caption="Original Image", use_column_width=True)
    # Getting the current figure and save it in the variable.
    fig = plt.gcf()
    # Download button for Original Image
    original_download_btn = col1.download_button("Download Original Image", convert_image(fig), "original_image.png", "image/png")

    # Plot Segmentation map
    col2.write('Segmentation Map')
    fig, ax = plt.subplots(1, 1, figsize=(8, 6))
    im = ax.imshow(np.squeeze(pred > 0.5))
    im2 = ax.imshow(np.squeeze(img), cmap='Greys', alpha=0.25)
    divider = make_axes_locatable(ax)
    cax = divider.append_axes("right", size="5%", pad=0.05)
    plt.colorbar(im, cax=cax, label="Uncertainty")
    ax.set_title('Uncertainty Map')
    # Getting the current figure and save it in the variable.
    fig = plt.gcf()
    col2.pyplot(fig)
    # Download button for Segmentation Map
    segmentation_download_btn = col2.download_button("Download Segmentation Map", convert_image(fig), "segmentation_map.png", "image/png")



    # Plot uncertainty map
    col3.write('Uncertainty Map')
    fig, ax = plt.subplots(1, 1, figsize=(8, 6))
    im = ax.imshow(np.squeeze(uncertainty), cmap='prism')
    im2 = ax.imshow(np.squeeze(img), cmap='Greys', alpha=0.25)
    divider = make_axes_locatable(ax)
    cax = divider.append_axes("right", size="5%", pad=0.05)
    plt.colorbar(im, cax=cax, label="Uncertainty")
    ax.set_title('Uncertainty Map')
    # Getting the current figure and save it in the variable.
    fig = plt.gcf()
    col3.pyplot(fig)
    # Download button for Uncertainty Map
    uncertainty_download_btn = col3.download_button("Download Uncertainty Map", convert_image(fig), "uncertainty_map.png", "image/png")



    return original_download_btn, segmentation_download_btn, uncertainty_download_btn

# Login Page
def login_page():
    st.write("# Nerve Structure Segmentation App")
    st.write("Login to access the app.")

    # Sample username and password
    username = st.text_input("Username")
    password = st.text_input("Password", type="password")

    if username == your_username and password == your_password:
        st.success("Login successful!")
        return True
    elif username != "" or password != "":
        st.error("Invalid credentials. Please try again.")

    return False

# Main App
def main():
    st.sidebar.write("## Upload and Download :gear:")

    # Theme Selector
    theme_mode = st.sidebar.radio("Select Theme Mode", ["Light", "Dark"])
    if theme_mode == "Dark":
        st.markdown('<style>body {background-color: #2C2C2C; color: white;}</style>', unsafe_allow_html=True)
    else:
        st.markdown('<style>body {background-color: #F5F5F5; color: black;}</style>', unsafe_allow_html=True)

    # File Uploader
    my_upload = st.sidebar.file_uploader("Upload an image", type=["png", "jpg", "jpeg"])

    col1, col2, col3 = st.columns(3)

    if my_upload is not None:
        if my_upload.size > MAX_FILE_SIZE:
            st.error("The uploaded file is too large. Please upload an image smaller than 5MB.")
        else:
            # Store uploaded image and corresponding plots in dictionary
            uploaded_images[my_upload.name] = segment_image(my_upload, col1, col2, col3)

    # Switching between light and dark mode
    st.sidebar.write("## Switch Theme Mode")
    if st.sidebar.button("Toggle Light/Dark Mode"):
        st.caching.clear_cache()
        st.experimental_rerun()  # Rerun the app with the new theme mode

# Main execution
if login_page():
    main()

